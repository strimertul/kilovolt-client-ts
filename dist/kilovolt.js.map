{
  "version": 3,
  "sources": ["../vendor/event-emitter.ts", "../utils.ts", "../index.ts"],
  "sourcesContent": ["/**\r\n * A simple and lightweight EventEmitter by TypeScript for Node.js or Browsers.\r\n *\r\n * @author billjs\r\n * @see https://github.com/billjs/event-emitter\r\n * @license MIT(https://opensource.org/licenses/MIT)\r\n */\r\n\r\n/**\r\n * EventHandler\r\n *\r\n * @export\r\n */\r\nexport type EventHandler = ((evt: Event) => void) & { _once?: boolean };\r\n\r\n/**\r\n * Event Object\r\n *\r\n * @export\r\n * @interface Event\r\n */\r\nexport interface Event {\r\n  /**\r\n   * event type\r\n   *\r\n   * @type {string}\r\n   * @memberof Event\r\n   */\r\n  type: string;\r\n\r\n  /**\r\n   * event data\r\n   *\r\n   * @type {*}\r\n   * @memberof Event\r\n   */\r\n  data: any;\r\n\r\n  /**\r\n   * the timestamp when event fired\r\n   *\r\n   * @type {number}\r\n   * @memberof Event\r\n   */\r\n  timestamp: number;\r\n\r\n  /**\r\n   * it is an once event, that meaning listen off after event fired\r\n   *\r\n   * @type {boolean}\r\n   * @memberof Event\r\n   */\r\n  once: boolean;\r\n}\r\n\r\n/**\r\n * It's a class for managing events.\r\n * It can be extended to provide event functionality for other classes or object.\r\n *\r\n * @export\r\n * @class EventEmitter\r\n */\r\nexport class EventEmitter {\r\n  /**\r\n   * the all event handlers are added.\r\n   * it's a Map data structure(key-value), the key is event type, and the value is event handler.\r\n   *\r\n   * @memberof EventEmitter\r\n   */\r\n  _eventHandlers: Record<string, EventHandler[] | undefined> = {};\r\n\r\n  /**\r\n   * event type validator.\r\n   *\r\n   * @param {string} type event type\r\n   * @returns {boolean}\r\n   * @memberof EventEmitter\r\n   */\r\n  isValidType(type: string) {\r\n    return typeof type === \"string\";\r\n  }\r\n\r\n  /**\r\n   * event handler validator.\r\n   *\r\n   * @param {EventHandler} handler event handler\r\n   * @returns {boolean}\r\n   * @memberof EventEmitter\r\n   */\r\n  isValidHandler(handler: EventHandler) {\r\n    return typeof handler === \"function\";\r\n  }\r\n\r\n  /**\r\n   * listen on a new event by type and handler.\r\n   * if listen on, the true is returned, otherwise the false.\r\n   * The handler will not be listen if it is a duplicate.\r\n   *\r\n   * @param {string} type event type, it must be a unique string.\r\n   * @param {EventHandler} handler event handler, when if the same handler is passed, listen it by only once.\r\n   * @returns {boolean}\r\n   * @memberof EventEmitter\r\n   * @example\r\n   *  const emitter = new EventEmitter();\r\n   *  emitter.on('change:name', evt => {\r\n   *    console.log(evt);\r\n   *  });\r\n   */\r\n  on(type: string, handler: EventHandler) {\r\n    if (!type || !handler) return false;\r\n\r\n    if (!this.isValidType(type)) return false;\r\n    if (!this.isValidHandler(handler)) return false;\r\n\r\n    let handlers = this._eventHandlers[type];\r\n    if (!handlers) handlers = this._eventHandlers[type] = [];\r\n\r\n    // when the same handler is passed, listen it by only once.\r\n    if (handlers.indexOf(handler) >= 0) return false;\r\n\r\n    handler._once = false;\r\n    handlers.push(handler);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * listen on an once event by type and handler.\r\n   * when the event is fired, that will be listen off immediately and automatically.\r\n   * The handler will not be listen if it is a duplicate.\r\n   *\r\n   * @param {string} type event type, it must be a unique string.\r\n   * @param {EventHandler} handler event handler, when if the same handler is passed, listen it by only once.\r\n   * @returns {boolean}\r\n   * @memberof EventEmitter\r\n   * @example\r\n   *  const emitter = new EventEmitter();\r\n   *  emitter.once('change:name', evt => {\r\n   *    console.log(evt);\r\n   *  });\r\n   */\r\n  once(type: string, handler: EventHandler) {\r\n    if (!type || !handler) return false;\r\n\r\n    if (!this.isValidType(type)) return false;\r\n    if (!this.isValidHandler(handler)) return false;\r\n\r\n    const ret = this.on(type, handler);\r\n    if (ret) {\r\n      // set `_once` private property after listened,\r\n      // avoid to modify event handler that has been listened.\r\n      handler._once = true;\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * listen off an event by type and handler.\r\n   * or listen off events by type, when if only type argument is passed.\r\n   * or listen off all events, when if no arguments are passed.\r\n   *\r\n   * @param {string} [type] event type\r\n   * @param {EventHandler} [handler] event handler\r\n   * @returns\r\n   * @memberof EventEmitter\r\n   * @example\r\n   *  const emitter = new EventEmitter();\r\n   *  // listen off the specified event\r\n   *  emitter.off('change:name', evt => {\r\n   *    console.log(evt);\r\n   *  });\r\n   *  // listen off events by type\r\n   *  emitter.off('change:name');\r\n   *  // listen off all events\r\n   *  emitter.off();\r\n   */\r\n  off(type?: string, handler?: EventHandler) {\r\n    // listen off all events, when if no arguments are passed.\r\n    // it does samething as `offAll` method.\r\n    if (!type) return this.offAll();\r\n\r\n    // listen off events by type, when if only type argument is passed.\r\n    if (!handler) {\r\n      this._eventHandlers[type] = [];\r\n      return;\r\n    }\r\n\r\n    if (!this.isValidType(type)) return;\r\n    if (!this.isValidHandler(handler)) return;\r\n\r\n    const handlers = this._eventHandlers[type];\r\n    if (!handlers || !handlers.length) return;\r\n\r\n    // otherwise, listen off the specified event.\r\n    for (let i = 0; i < handlers.length; i++) {\r\n      const fn = handlers[i];\r\n      if (fn === handler) {\r\n        handlers.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * listen off all events, that means every event will be emptied.\r\n   *\r\n   * @memberof EventEmitter\r\n   * @example\r\n   *  const emitter = new EventEmitter();\r\n   *  emitter.offAll();\r\n   */\r\n  offAll() {\r\n    this._eventHandlers = {};\r\n  }\r\n\r\n  /**\r\n   * fire the specified event, and you can to pass a data.\r\n   * When fired, every handler attached to that event will be executed.\r\n   * But, if it's an once event, listen off it immediately after called handler.\r\n   *\r\n   * @param {string} type event type\r\n   * @param {*} [data] event data\r\n   * @returns\r\n   * @memberof EventEmitter\r\n   * @example\r\n   *  const emitter = new EventEmitter();\r\n   *  emitter.fire('change:name', 'new name');\r\n   */\r\n  fire(type: string, data?: any) {\r\n    if (!type || !this.isValidType(type)) return;\r\n\r\n    const handlers = this._eventHandlers[type];\r\n    if (!handlers || !handlers.length) return;\r\n\r\n    const event = this.createEvent(type, data);\r\n\r\n    for (const handler of handlers) {\r\n      if (!this.isValidHandler(handler)) continue;\r\n      if (handler._once) event.once = true;\r\n\r\n      // call event handler, and pass the event argument.\r\n      handler(event);\r\n\r\n      // if it's an once event, listen off it immediately after called handler.\r\n      if (event.once) this.off(type, handler);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * check whether the specified event has been listen on.\r\n   * or check whether the events by type has been listen on, when if only `type` argument is passed.\r\n   *\r\n   * @param {string} type event type\r\n   * @param {EventHandler} [handler] event handler, optional\r\n   * @returns {boolean}\r\n   * @memberof EventEmitter\r\n   * @example\r\n   *  const emitter = new EventEmitter();\r\n   *  const result = emitter.has('change:name');\r\n   */\r\n  has(type: string, handler?: EventHandler) {\r\n    if (!type || !this.isValidType(type)) return false;\r\n\r\n    const handlers = this._eventHandlers[type];\r\n    // if there are no any events, return false.\r\n    if (!handlers || !handlers.length) return false;\r\n\r\n    // at lest one event, and no pass `handler` argument, then return true.\r\n    if (!handler || !this.isValidHandler(handler)) return true;\r\n\r\n    // otherwise, need to traverse the handlers.\r\n    return handlers.indexOf(handler) >= 0;\r\n  }\r\n\r\n  /**\r\n   * get the handlers for the specified event type.\r\n   *\r\n   * @param {string} type event type\r\n   * @returns {EventHandler[]}\r\n   * @memberof EventEmitter\r\n   * @example\r\n   *  const emitter = new EventEmitter();\r\n   *  const handlers = emitter.getHandlers('change:name');\r\n   *  console.log(handlers);\r\n   */\r\n  getHandlers(type: string) {\r\n    if (!type || !this.isValidType(type)) return [];\r\n    return this._eventHandlers[type] || [];\r\n  }\r\n\r\n  /**\r\n   * create event object.\r\n   *\r\n   * @param {string} type event type\r\n   * @param {*} [data] event data\r\n   * @param {boolean} [once=false] is it an once event?\r\n   * @returns {Event}\r\n   * @memberof EventEmitter\r\n   */\r\n  createEvent(type: string, data?: any, once = false) {\r\n    const event: Event = { type, data, timestamp: Date.now(), once };\r\n    return event;\r\n  }\r\n}\r\n\r\n/**\r\n * EventEmitter instance for global.\r\n * @type {EventEmitter}\r\n */\r\nexport const globalEvent = new EventEmitter();\r\n", "// https://stackoverflow.com/a/62364519\r\nexport function base64ToBytesArr(str: string) {\r\n  const abc = [\r\n    ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\r\n  ]; // base64 alphabet\r\n  const result = [];\r\n\r\n  for (let i = 0; i < str.length / 4; i++) {\r\n    let chunk = [...str.slice(4 * i, 4 * i + 4)];\r\n    let bin = chunk\r\n      .map((x) => abc.indexOf(x).toString(2).padStart(6, \"0\"))\r\n      .join(\"\");\r\n    let bytes = bin.match(/.{1,8}/g)!.map((x) => +(\"0b\" + x));\r\n    result.push(\r\n      ...bytes.slice(\r\n        0,\r\n        3 - (str[4 * i + 2] == \"=\" ? 1 : 0) - (str[4 * i + 3] == \"=\" ? 1 : 0)\r\n      )\r\n    );\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function bytesArrToBase64(arr: number[]) {\r\n  const abc =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // base64 alphabet\r\n  const bin = (n: number) => n.toString(2).padStart(8, \"0\"); // convert num to 8-bit binary string\r\n  const l = arr.length;\r\n  let result = \"\";\r\n\r\n  for (let i = 0; i <= (l - 1) / 3; i++) {\r\n    const c1 = i * 3 + 1 >= l; // case when \"=\" is on end\r\n    const c2 = i * 3 + 2 >= l; // case when \"=\" is on end\r\n    const chunk =\r\n      bin(arr[3 * i]) +\r\n      bin(c1 ? 0 : arr[3 * i + 1]) +\r\n      bin(c2 ? 0 : arr[3 * i + 2]);\r\n    const r = chunk\r\n      .match(/.{1,6}/g)!\r\n      .map((x, j) =>\r\n        j == 3 && c2 ? \"=\" : j == 2 && c1 ? \"=\" : abc[+(\"0b\" + x)]\r\n      );\r\n    result += r.join(\"\");\r\n  }\r\n\r\n  return result;\r\n}\r\n", "import { EventEmitter } from \"./vendor/event-emitter.ts\";\r\nimport { base64ToBytesArr, bytesArrToBase64 } from \"./utils.ts\";\r\nimport {\r\n  kvGet,\r\n  kvGetBulk,\r\n  kvGetAll,\r\n  kvSet,\r\n  kvSetBulk,\r\n  kvSubscribeKey,\r\n  kvUnsubscribeKey,\r\n  kvSubscribePrefix,\r\n  kvUnsubscribePrefix,\r\n  kvVersion,\r\n  kvKeyList,\r\n  kvLogin,\r\n  kvError,\r\n  kvPush,\r\n  KilovoltResponse,\r\n  kvGenericResponse,\r\n  kvAuth,\r\n  kvEmptyResponse,\r\n} from \"./messages.ts\";\r\n\r\nexport type SubscriptionHandler = (newValue: string, key: string) => void;\r\n\r\nexport type KilovoltRequest =\r\n  | kvGet\r\n  | kvGetBulk\r\n  | kvGetAll\r\n  | kvSet\r\n  | kvSetBulk\r\n  | kvSubscribeKey\r\n  | kvUnsubscribeKey\r\n  | kvSubscribePrefix\r\n  | kvUnsubscribePrefix\r\n  | kvVersion\r\n  | kvKeyList\r\n  | kvLogin\r\n  | kvAuth;\r\n\r\nexport type KilovoltMessage = kvError | kvPush | KilovoltResponse;\r\n\r\n/**\r\n * Simple random function for generating request IDs\r\n * Note: not cryptographically secure!\r\n * @returns Random hex string\r\n */\r\nfunction generateRid() {\r\n  return Math.random().toString(32);\r\n}\r\n\r\n/**\r\n * Calculate and encode the hash for authentication challenges using Web Crypto API\r\n * @param password Shared key for authentication\r\n * @param challenge Base64 of the received challenge\r\n * @param salt Base64 of the received salt\r\n * @returns Base64 encoded hash\r\n */\r\nasync function authChallenge(\r\n  password: string,\r\n  challenge: string,\r\n  salt: string\r\n) {\r\n  // Encode password\r\n  const enc = new TextEncoder();\r\n  const keyBytes = enc.encode(password);\r\n  const saltBytes = base64ToBytesArr(salt);\r\n  const challengeKey = Uint8Array.from([...keyBytes, ...saltBytes]);\r\n  const challengeBytes = base64ToBytesArr(challenge);\r\n\r\n  const key = await window.crypto.subtle.importKey(\r\n    \"raw\",\r\n    challengeKey,\r\n    { name: \"HMAC\", hash: { name: \"SHA-256\" } },\r\n    false,\r\n    [\"sign\", \"verify\"]\r\n  );\r\n  const signature = await window.crypto.subtle.sign(\r\n    \"HMAC\",\r\n    key,\r\n    Uint8Array.from(challengeBytes)\r\n  );\r\n  return bytesArrToBase64(Array.from(new Uint8Array(signature)));\r\n}\r\n\r\nexport class Kilovolt extends EventEmitter {\r\n  private socket!: WebSocket;\r\n\r\n  private password?: string;\r\n  private address: string;\r\n\r\n  private pending: Record<string, (response: KilovoltMessage) => void>;\r\n\r\n  private keySubscriptions: Record<string, SubscriptionHandler[]>;\r\n  private prefixSubscriptions: Record<string, SubscriptionHandler[]>;\r\n\r\n  /**\r\n   * Create a new Kilovolt client instance and connect to it\r\n   * @param address Kilovolt server endpoint (including path)\r\n   */\r\n  constructor(address = \"ws://localhost:4337/ws\", password?: string) {\r\n    super();\r\n    this.address = address;\r\n    this.password = password;\r\n    this.pending = {};\r\n    this.keySubscriptions = {};\r\n    this.prefixSubscriptions = {};\r\n    this.connect(address);\r\n  }\r\n\r\n  /**\r\n   * Re-connect to kilovolt server\r\n   */\r\n  reconnect(): void {\r\n    this.connect(this.address);\r\n  }\r\n\r\n  private connect(address: string): void {\r\n    this.socket = new WebSocket(address);\r\n    this.socket.addEventListener(\"open\", this.open.bind(this));\r\n    this.socket.addEventListener(\"message\", this.received.bind(this));\r\n    this.socket.addEventListener(\"close\", this.closed.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Wait for websocket connection to be established\r\n   */\r\n  async wait(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      if (this.socket.readyState === this.socket.OPEN) {\r\n        resolve();\r\n        return;\r\n      }\r\n      this.once(\"open\", () => resolve());\r\n    });\r\n  }\r\n\r\n  private async open() {\r\n    console.info(\"connected to server\");\r\n    // Authenticate if needed\r\n    if (this.password) {\r\n      try {\r\n        await this.auth();\r\n      } catch (e) {\r\n        this.fire(\"error\", e);\r\n        this.socket.close();\r\n      }\r\n    }\r\n    this.fire(\"open\");\r\n    this.fire(\"stateChange\", this.socket.readyState);\r\n  }\r\n\r\n  private closed() {\r\n    console.warn(\"lost connection to server\");\r\n    this.fire(\"close\");\r\n    this.fire(\"stateChange\", this.socket.readyState);\r\n  }\r\n\r\n  private received(event: MessageEvent) {\r\n    const events = (event.data as string)\r\n      .split(\"\\n\")\r\n      .map((ev) => ev.trim())\r\n      .filter((ev) => ev.length > 0);\r\n    events.forEach((ev) => {\r\n      const response: KilovoltMessage = JSON.parse(ev ?? '\"\"');\r\n      if (\"error\" in response) {\r\n        this.fire(\"error\", response);\r\n        return;\r\n      }\r\n      switch (response.type) {\r\n        case \"response\":\r\n          if (response.request_id in this.pending) {\r\n            this.pending[response.request_id](response);\r\n            delete this.pending[response.request_id];\r\n          } else {\r\n            console.warn(\r\n              \"Received a response for an unregistered request: \",\r\n              response\r\n            );\r\n          }\r\n          break;\r\n        case \"push\": {\r\n          if (response.key in this.keySubscriptions) {\r\n            this.keySubscriptions[response.key].forEach((fn) =>\r\n              fn(response.new_value, response.key)\r\n            );\r\n          }\r\n          Object.entries(this.prefixSubscriptions)\r\n            .filter(([k]) => response.key.startsWith(k))\r\n            .forEach(([_, subscribers]) => {\r\n              subscribers.forEach((fn) => fn(response.new_value, response.key));\r\n            });\r\n          break;\r\n        }\r\n        default:\r\n        // Do nothing\r\n      }\r\n    });\r\n  }\r\n\r\n  private async auth() {\r\n    // Ask for challenge\r\n    const request = (await this.send<kvLogin>({ command: \"klogin\" })) as\r\n      | kvError\r\n      | kvGenericResponse<{ challenge: string; salt: string }>;\r\n    if (\"error\" in request) {\r\n      throw new Error(request.error);\r\n    }\r\n    // Calculate hash and send back\r\n    const hash = await authChallenge(\r\n      this.password ?? \"\",\r\n      request.data.challenge,\r\n      request.data.salt\r\n    );\r\n    const response = (await this.send<kvAuth>({\r\n      command: \"kauth\",\r\n      data: { hash },\r\n    })) as kvError | kvEmptyResponse;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a request to the server\r\n   * @param msg Request to send\r\n   * @returns Response from server\r\n   */\r\n  async send<T extends KilovoltRequest>(\r\n    msg: T | Omit<T, \"request_id\">\r\n  ): Promise<KilovoltMessage> {\r\n    const message = {\r\n      ...msg,\r\n      request_id: \"request_id\" in msg ? msg.request_id : generateRid(),\r\n    };\r\n    return new Promise((resolve) => {\r\n      const payload = JSON.stringify(message);\r\n      this.socket.send(payload);\r\n      this.pending[message.request_id] = resolve;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set a key to a specified value\r\n   * @param key Key to set\r\n   * @param data Value to set\r\n   * @returns Reply from server\r\n   */\r\n  async putKey(key: string, data: string): Promise<KilovoltMessage> {\r\n    return this.send<kvSet>({\r\n      command: \"kset\",\r\n      data: {\r\n        key,\r\n        data,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set multiple keys at once\r\n   * @param data Map of key:value data to set\r\n   * @returns Reply from server\r\n   */\r\n  async putKeys(data: Record<string, string>): Promise<KilovoltMessage> {\r\n    return this.send<kvSetBulk>({\r\n      command: \"kset-bulk\",\r\n      data,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set a key to the JSON representation of an object\r\n   * @param key Key to set\r\n   * @param data Object to save\r\n   * @returns Reply from server\r\n   */\r\n  async putJSON<T>(key: string, data: T): Promise<KilovoltMessage> {\r\n    return this.send<kvSet>({\r\n      command: \"kset\",\r\n      data: {\r\n        key,\r\n        data: JSON.stringify(data),\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set multiple keys at once\r\n   * @param data Map of key:value data to set\r\n   * @returns Reply from server\r\n   */\r\n  async putJSONs(data: Record<string, unknown>): Promise<KilovoltMessage> {\r\n    const jsonData: Record<string, string> = {};\r\n    Object.entries(data).forEach(([k, v]) => {\r\n      jsonData[k] = JSON.stringify(v);\r\n    });\r\n    return this.send<kvSetBulk>({\r\n      command: \"kset-bulk\",\r\n      data: jsonData,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieve value for key\r\n   * @param key Key to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getKey(key: string): Promise<string> {\r\n    const response = (await this.send<kvGet>({\r\n      command: \"kget\",\r\n      data: {\r\n        key,\r\n      },\r\n    })) as kvError | kvGenericResponse<string>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * Retrieve value for key\r\n   * @param keys Keys to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getKeys(keys: string[]): Promise<Record<string, string>> {\r\n    const response = (await this.send<kvGetBulk>({\r\n      command: \"kget-bulk\",\r\n      data: {\r\n        keys,\r\n      },\r\n    })) as kvError | kvGenericResponse<Record<string, string>>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * Retrieve all keys with given prefix\r\n   * @param prefix Prefix for keys to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getKeysByPrefix(prefix: string): Promise<Record<string, string>> {\r\n    const response = (await this.send<kvGetAll>({\r\n      command: \"kget-all\",\r\n      data: {\r\n        prefix,\r\n      },\r\n    })) as kvError | kvGenericResponse<Record<string, string>>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * Retrieve object from key, deserialized from JSON.\r\n   * It's your responsibility to make sure the object is actually what you expect\r\n   * @param key Key to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getJSON<T>(key: string): Promise<T> {\r\n    const response = (await this.send<kvGet>({\r\n      command: \"kget\",\r\n      data: {\r\n        key,\r\n      },\r\n    })) as kvError | kvGenericResponse<string>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return JSON.parse(response.data);\r\n  }\r\n\r\n  /**\r\n   * Retrieve objects from keys, deserialized from JSON.\r\n   * It's your responsibility to make sure the object is actually what you expect\r\n   * @param key Key to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getJSONs<T>(keys: string[]): Promise<T> {\r\n    const response = (await this.send<kvGetBulk>({\r\n      command: \"kget-bulk\",\r\n      data: {\r\n        keys,\r\n      },\r\n    })) as kvError | kvGenericResponse<Record<string, string>>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    const returnData: Record<string, unknown> = {};\r\n    Object.entries(response.data).forEach(([k, v]) => {\r\n      returnData[k] = JSON.parse(v);\r\n    });\r\n    return returnData as T;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to key changes\r\n   * @param key Key to subscribe to\r\n   * @param fn Callback to call when key changes\r\n   * @returns Reply from server\r\n   */\r\n  async subscribeKey(\r\n    key: string,\r\n    fn: SubscriptionHandler\r\n  ): Promise<KilovoltMessage> {\r\n    if (key in this.keySubscriptions) {\r\n      this.keySubscriptions[key].push(fn);\r\n    } else {\r\n      this.keySubscriptions[key] = [fn];\r\n    }\r\n\r\n    return this.send<kvSubscribeKey>({\r\n      command: \"ksub\",\r\n      data: {\r\n        key,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop calling a callback when its related key changes\r\n   * This only\r\n   * @param key Key to unsubscribe from\r\n   * @param fn Callback to stop calling\r\n   * @returns true if a subscription was removed, false otherwise\r\n   */\r\n  async unsubscribeKey(key: string, fn: SubscriptionHandler): Promise<boolean> {\r\n    if (!(key in this.keySubscriptions)) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from key \"${key}\" but no subscriptions could be found!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Get subscriber in list\r\n    const index = this.keySubscriptions[key].findIndex((subfn) => subfn === fn);\r\n    if (index < 0) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from key \"${key}\" but specified function is not in the subscribers!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Remove subscriber from list\r\n    this.keySubscriptions[key].splice(index, 1);\r\n\r\n    // Check if array is empty\r\n    if (this.keySubscriptions[key].length < 1) {\r\n      // Send unsubscribe\r\n      const res = (await this.send<kvUnsubscribeKey>({\r\n        command: \"kunsub\",\r\n        data: {\r\n          key,\r\n        },\r\n      })) as kvError | kvGenericResponse<void>;\r\n      if (\"error\" in res) {\r\n        console.warn(`unsubscribe failed: ${res.error}`);\r\n      }\r\n      return res.ok;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to key changes on a prefix\r\n   * @param prefix Prefix of keys to subscribe to\r\n   * @param fn Callback to call when key changes\r\n   * @returns Reply from server\r\n   */\r\n  async subscribePrefix(\r\n    prefix: string,\r\n    fn: SubscriptionHandler\r\n  ): Promise<KilovoltMessage> {\r\n    if (prefix in this.keySubscriptions) {\r\n      this.prefixSubscriptions[prefix].push(fn);\r\n    } else {\r\n      this.prefixSubscriptions[prefix] = [fn];\r\n    }\r\n\r\n    return this.send<kvSubscribePrefix>({\r\n      command: \"ksub-prefix\",\r\n      data: {\r\n        prefix,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop calling a callback when their prefix's related key changes\r\n   * This only\r\n   * @param prefix Prefix to unsubscribe from\r\n   * @param fn Callback to stop calling\r\n   * @returns true if a subscription was removed, false otherwise\r\n   */\r\n  async unsubscribePrefix(\r\n    prefix: string,\r\n    fn: SubscriptionHandler\r\n  ): Promise<boolean> {\r\n    if (!(prefix in this.prefixSubscriptions)) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from prefix \"${prefix}\" but no subscriptions could be found!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Get subscriber in list\r\n    const index = this.prefixSubscriptions[prefix].findIndex(\r\n      (subfn) => subfn === fn\r\n    );\r\n    if (index < 0) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from key \"${prefix}\" but specified function is not in the subscribers!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Remove subscriber from list\r\n    this.prefixSubscriptions[prefix].splice(index, 1);\r\n\r\n    // Check if array is empty\r\n    if (this.prefixSubscriptions[prefix].length < 1) {\r\n      // Send unsubscribe\r\n      const res = (await this.send<kvUnsubscribePrefix>({\r\n        command: \"kunsub-prefix\",\r\n        data: {\r\n          prefix,\r\n        },\r\n      })) as kvError | kvGenericResponse<void>;\r\n      if (\"error\" in res) {\r\n        console.warn(`unsubscribe failed: ${res.error}`);\r\n      }\r\n      return res.ok;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of saved keys with the given prefix.\r\n   * If no prefix is given then returns all the keys.\r\n   * @param prefix Optional prefix\r\n   * @returns List of keys\r\n   */\r\n  async keyList(prefix?: string): Promise<string[]> {\r\n    const response = (await this.send<kvKeyList>({\r\n      command: \"klist\",\r\n      data: {\r\n        prefix: prefix ?? \"\",\r\n      },\r\n    })) as kvError | kvGenericResponse<string[]>;\r\n\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n\r\n    return response.data;\r\n  }\r\n}\r\n\r\nexport default Kilovolt;\r\n"],
  "mappings": "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",
  "names": []
}
