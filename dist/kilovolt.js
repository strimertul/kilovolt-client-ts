var g=Object.defineProperty,w=Object.defineProperties;var E=Object.getOwnPropertyDescriptors;var b=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable;var v=(i,n,e)=>n in i?g(i,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[n]=e,f=(i,n)=>{for(var e in n||(n={}))P.call(n,e)&&v(i,e,n[e]);if(b)for(var e of b(n))K.call(n,e)&&v(i,e,n[e]);return i},m=(i,n)=>w(i,E(n)),c=(i,n)=>g(i,"name",{value:n,configurable:!0});function k(i){let n=[..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],e=[];for(let s=0;s<i.length/4;s++){let o=[...i.slice(4*s,4*s+4)].map(a=>n.indexOf(a).toString(2).padStart(6,"0")).join("").match(/.{1,8}/g).map(a=>+("0b"+a));e.push(...o.slice(0,3-(i[4*s+2]=="="?1:0)-(i[4*s+3]=="="?1:0)))}return e}c(k,"base64ToBytesArr");function y(i){let n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",e=c(t=>t.toString(2).padStart(8,"0"),"bin"),s=i.length,r="";for(let t=0;t<=(s-1)/3;t++){let o=t*3+1>=s,a=t*3+2>=s,l=(e(i[3*t])+e(o?0:i[3*t+1])+e(a?0:i[3*t+2])).match(/.{1,6}/g).map((S,p)=>p==3&&a||p==2&&o?"=":n[+("0b"+S)]);r+=l.join("")}return r}c(y,"bytesArrToBase64");var u=class extends EventTarget{on(n,e){return this.addEventListener(n,e)}once(n,e){return this.addEventListener(n,e,{once:!0})}off(n,e){return this.removeEventListener(n,e)}fire(n,e){return this.dispatchEvent(new CustomEvent(n,{detail:e,cancelable:!0}))}};c(u,"EventEmitter");function x(){return Math.random().toString(32)}c(x,"generateRid");async function R(i,n,e){let r=new TextEncoder().encode(i),t=k(e),o=Uint8Array.from([...r,...t]),a=k(n),d=await crypto.subtle.importKey("raw",o,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"]),l=await crypto.subtle.sign("HMAC",d,Uint8Array.from(a));return y(Array.from(new Uint8Array(l)))}c(R,"authChallenge");var h=class extends u{constructor(e="ws://localhost:4337/ws",s,r){super();this.address=e,this.password=s,this.pending={},this.keySubscriptions={},this.prefixSubscriptions={},this.options=r||{},this.connect(e)}reconnect(){this.connect(this.address)}close(){this.options.reconnect=!1,this.socket.close()}connect(e){this.socket=new WebSocket(e),this.socket.addEventListener("open",this.open.bind(this)),this.socket.addEventListener("message",this.received.bind(this)),this.socket.addEventListener("close",this.closed.bind(this)),this.socket.addEventListener("error",this.errored.bind(this))}wait(){return new Promise(e=>{if(this.socket.readyState===this.socket.OPEN){e();return}this.once("open",()=>e())})}async open(){if(console.info("connected to server"),this.password)try{await this.auth()}catch(e){this.fire("error",e),this.close()}this.resubscribe(),this.fire("open"),this.fire("stateChange",this.socket.readyState)}closed(e){console.warn(`lost connection to server: ${e.reason}`),this.fire("close",e),this.fire("stateChange",this.socket.readyState),this.options.reconnect&&setTimeout(()=>this.reconnect(),5e3)}errored(e){this.fire("error",e)}received(e){e.data.split(`
`).map(r=>r.trim()).filter(r=>r.length>0).forEach(r=>{let t=JSON.parse(r!=null?r:'""');if("error"in t){this.fire("error",t),"request_id"in t&&t.request_id in this.pending&&(this.pending[t.request_id](t),delete this.pending[t.request_id]);return}switch(t.type){case"response":t.request_id in this.pending?(this.pending[t.request_id](t),delete this.pending[t.request_id]):console.warn("Received a response for an unregistered request: ",t);break;case"push":{t.key in this.keySubscriptions&&this.keySubscriptions[t.key].forEach(o=>o(t.new_value,t.key)),Object.entries(this.prefixSubscriptions).filter(([o])=>t.key.startsWith(o)).forEach(([o,a])=>{a.forEach(d=>d(t.new_value,t.key))});break}default:}})}async auth(){var t;let e=await this.send({command:"klogin"});if("error"in e)throw console.error("kilovolt auth error:",e.error),new Error(e.error);let s=await R((t=this.password)!=null?t:"",e.data.challenge,e.data.salt),r=await this.send({command:"kauth",data:{hash:s}});if("error"in r)throw console.error("kilovolt auth error:",r.error),new Error(r.error)}async resubscribe(){for(let e in this.keySubscriptions)await this.send({command:"ksub",data:{key:e}});for(let e in this.prefixSubscriptions)this.send({command:"ksub-prefix",data:{prefix:e}})}send(e){if(this.socket.readyState!==this.socket.OPEN)throw new Error("Not connected to server");let s=m(f({},e),{request_id:"request_id"in e?e.request_id:x()});return new Promise(r=>{let t=JSON.stringify(s);this.socket.send(t),this.pending[s.request_id]=r})}putKey(e,s){return this.send({command:"kset",data:{key:e,data:s}})}putKeys(e){return this.send({command:"kset-bulk",data:e})}putJSON(e,s){return this.send({command:"kset",data:{key:e,data:JSON.stringify(s)}})}putJSONs(e){let s={};return Object.entries(e).forEach(([r,t])=>{s[r]=JSON.stringify(t)}),this.send({command:"kset-bulk",data:s})}async getKey(e){let s=await this.send({command:"kget",data:{key:e}});if("error"in s)throw new Error(s.error);return s.data}async getKeys(e){let s=await this.send({command:"kget-bulk",data:{keys:e}});if("error"in s)throw new Error(s.error);return s.data}async getKeysByPrefix(e){let s=await this.send({command:"kget-all",data:{prefix:e}});if("error"in s)throw new Error(s.error);return s.data}async getJSON(e){let s=await this.send({command:"kget",data:{key:e}});if("error"in s)throw new Error(s.error);return JSON.parse(s.data)}async getJSONs(e){let s=await this.send({command:"kget-bulk",data:{keys:e}});if("error"in s)throw new Error(s.error);let r={};return Object.entries(s.data).forEach(([t,o])=>{r[t]=JSON.parse(o)}),r}subscribeKey(e,s){return e in this.keySubscriptions?this.keySubscriptions[e].push(s):this.keySubscriptions[e]=[s],this.send({command:"ksub",data:{key:e}})}async unsubscribeKey(e,s){if(!(e in this.keySubscriptions))return console.warn(`Trying to unsubscribe from key "${e}" but no subscriptions could be found!`),!1;let r=this.keySubscriptions[e].findIndex(t=>t===s);if(r<0)return console.warn(`Trying to unsubscribe from key "${e}" but specified function is not in the subscribers!`),!1;if(this.keySubscriptions[e].splice(r,1),this.keySubscriptions[e].length<1){let t=await this.send({command:"kunsub",data:{key:e}});return"error"in t&&console.warn(`unsubscribe failed: ${t.error}`),t.ok}return!0}subscribePrefix(e,s){return e in this.keySubscriptions?this.prefixSubscriptions[e].push(s):this.prefixSubscriptions[e]=[s],this.send({command:"ksub-prefix",data:{prefix:e}})}async unsubscribePrefix(e,s){if(!(e in this.prefixSubscriptions))return console.warn(`Trying to unsubscribe from prefix "${e}" but no subscriptions could be found!`),!1;let r=this.prefixSubscriptions[e].findIndex(t=>t===s);if(r<0)return console.warn(`Trying to unsubscribe from key "${e}" but specified function is not in the subscribers!`),!1;if(this.prefixSubscriptions[e].splice(r,1),this.prefixSubscriptions[e].length<1){let t=await this.send({command:"kunsub-prefix",data:{prefix:e}});return"error"in t&&console.warn(`unsubscribe failed: ${t.error}`),t.ok}return!0}async keyList(e){let s=await this.send({command:"klist",data:{prefix:e!=null?e:""}});if("error"in s)throw new Error(s.error);return s.data}};c(h,"Kilovolt");var A=h;export{h as Kilovolt,A as default};
//# sourceMappingURL=kilovolt.js.map
