{
  "version": 3,
  "sources": ["../utils.ts", "../index.ts"],
  "sourcesContent": ["const b64alphabet =\r\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\nconst b64array = [...b64alphabet];\r\n\r\n// https://stackoverflow.com/a/62364519\r\nexport function base64ToBytesArr(str: string) {\r\n  const result = [];\r\n\r\n  for (let i = 0; i < str.length / 4; i++) {\r\n    const chunk = [...str.slice(4 * i, 4 * i + 4)];\r\n    const bin = chunk\r\n      .map((x) => b64array.indexOf(x).toString(2).padStart(6, \"0\"))\r\n      .join(\"\");\r\n    const bytes = bin.match(/.{1,8}/g)!.map((x) => +(\"0b\" + x));\r\n    result.push(\r\n      ...bytes.slice(\r\n        0,\r\n        3 - (str[4 * i + 2] == \"=\" ? 1 : 0) - (str[4 * i + 3] == \"=\" ? 1 : 0)\r\n      )\r\n    );\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function bytesArrToBase64(arr: number[]) {\r\n  const bin = (n: number) => n.toString(2).padStart(8, \"0\"); // convert num to 8-bit binary string\r\n  const l = arr.length;\r\n  let result = \"\";\r\n\r\n  for (let i = 0; i <= (l - 1) / 3; i++) {\r\n    const c1 = i * 3 + 1 >= l; // case when \"=\" is on end\r\n    const c2 = i * 3 + 2 >= l; // case when \"=\" is on end\r\n    const chunk =\r\n      bin(arr[3 * i]) +\r\n      bin(c1 ? 0 : arr[3 * i + 1]) +\r\n      bin(c2 ? 0 : arr[3 * i + 2]);\r\n    const r = chunk\r\n      .match(/.{1,6}/g)!\r\n      .map((x, j) =>\r\n        j == 3 && c2 ? \"=\" : j == 2 && c1 ? \"=\" : b64alphabet[+(\"0b\" + x)]\r\n      );\r\n    result += r.join(\"\");\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport class EventEmitter extends EventTarget {\r\n  on(eventName: string, listener: EventListenerOrEventListenerObject) {\r\n    return this.addEventListener(eventName, listener);\r\n  }\r\n  once(eventName: string, listener: EventListenerOrEventListenerObject) {\r\n    return this.addEventListener(eventName, listener, { once: true });\r\n  }\r\n  off(eventName: string, listener: EventListenerOrEventListenerObject) {\r\n    return this.removeEventListener(eventName, listener);\r\n  }\r\n  protected fire<T>(eventName: string, detail?: T) {\r\n    return this.dispatchEvent(\r\n      new CustomEvent(eventName, { detail, cancelable: true })\r\n    );\r\n  }\r\n}\r\n", "import { base64ToBytesArr, bytesArrToBase64, EventEmitter } from \"./utils.ts\";\r\nimport {\r\n  kvGet,\r\n  kvGetBulk,\r\n  kvGetAll,\r\n  kvSet,\r\n  kvSetBulk,\r\n  kvSubscribeKey,\r\n  kvUnsubscribeKey,\r\n  kvSubscribePrefix,\r\n  kvUnsubscribePrefix,\r\n  kvVersion,\r\n  kvKeyList,\r\n  kvLogin,\r\n  kvError,\r\n  kvPush,\r\n  KilovoltResponse,\r\n  kvGenericResponse,\r\n  kvAuth,\r\n  kvEmptyResponse,\r\n  kvInternalClientID,\r\n  kvDelete,\r\n} from \"./messages.ts\";\r\n\r\nexport type SubscriptionHandler = (newValue: string, key: string) => void;\r\n\r\nexport type KilovoltRequest =\r\n  | kvGet\r\n  | kvGetBulk\r\n  | kvGetAll\r\n  | kvSet\r\n  | kvSetBulk\r\n  | kvSubscribeKey\r\n  | kvUnsubscribeKey\r\n  | kvSubscribePrefix\r\n  | kvUnsubscribePrefix\r\n  | kvVersion\r\n  | kvKeyList\r\n  | kvDelete\r\n  | kvLogin\r\n  | kvAuth\r\n  | kvInternalClientID;\r\n\r\nexport type KilovoltMessage = kvError | kvPush | KilovoltResponse;\r\n\r\n/**\r\n * Simple random function for generating request IDs\r\n * Note: not cryptographically secure!\r\n * @returns Random hex string\r\n */\r\nfunction generateRid() {\r\n  return Math.random().toString(32);\r\n}\r\n\r\n/**\r\n * Calculate and encode the hash for authentication challenges using Web Crypto API\r\n * @param password Shared key for authentication\r\n * @param challenge Base64 of the received challenge\r\n * @param salt Base64 of the received salt\r\n * @returns Base64 encoded hash\r\n */\r\nasync function authChallenge(\r\n  password: string,\r\n  challenge: string,\r\n  salt: string\r\n) {\r\n  // Encode password\r\n  const enc = new TextEncoder();\r\n  const keyBytes = enc.encode(password);\r\n  const saltBytes = base64ToBytesArr(salt);\r\n  const challengeKey = Uint8Array.from([...keyBytes, ...saltBytes]);\r\n  const challengeBytes = base64ToBytesArr(challenge);\r\n\r\n  const key = await crypto.subtle.importKey(\r\n    \"raw\",\r\n    challengeKey,\r\n    { name: \"HMAC\", hash: { name: \"SHA-256\" } },\r\n    false,\r\n    [\"sign\", \"verify\"]\r\n  );\r\n  const signature = await crypto.subtle.sign(\r\n    \"HMAC\",\r\n    key,\r\n    Uint8Array.from(challengeBytes)\r\n  );\r\n  return bytesArrToBase64(Array.from(new Uint8Array(signature)));\r\n}\r\n\r\ninterface ClientOptions {\r\n  /* If true, reconnect to the server if the connection gets terminated for any reason */\r\n  reconnect?: boolean;\r\n\r\n  /* If provided, authenticate non-interactively as soon as connection is established */\r\n  password?: string;\r\n\r\n  /* If true, authenticate interactively as soon as connection is established */\r\n  interactive?: boolean;\r\n\r\n  /* When authenticating interactively, this data is added to the auth message */\r\n  interactiveData?: Record<string, unknown>;\r\n}\r\n\r\nexport class Kilovolt extends EventEmitter {\r\n  private socket!: WebSocket;\r\n\r\n  private address: string;\r\n  private options: ClientOptions;\r\n\r\n  private pending: Record<string, (response: KilovoltMessage) => void>;\r\n\r\n  private keySubscriptions: Record<string, SubscriptionHandler[]>;\r\n  private prefixSubscriptions: Record<string, SubscriptionHandler[]>;\r\n\r\n  /**\r\n   * Create a new Kilovolt client instance and connect to it\r\n   * @param address Kilovolt server endpoint (including path)\r\n   */\r\n  constructor(address = \"ws://localhost:4337/ws\", options?: ClientOptions) {\r\n    super();\r\n    this.address = address;\r\n    this.pending = {};\r\n    this.keySubscriptions = {};\r\n    this.prefixSubscriptions = {};\r\n    this.options = options || {\r\n      reconnect: true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Re-connect to kilovolt server\r\n   */\r\n  reconnect(): void {\r\n    this.connect();\r\n  }\r\n\r\n  /**\r\n   * Close connection to server\r\n   */\r\n  close(): void {\r\n    this.options.reconnect = false;\r\n    this.socket.close();\r\n  }\r\n\r\n  /**\r\n   * Connect to the Kilovolt server\r\n   */\r\n  async connect() {\r\n    this.socket = new WebSocket(this.address);\r\n    this.socket.addEventListener(\"open\", this.open.bind(this));\r\n    this.socket.addEventListener(\"message\", this.received.bind(this));\r\n    this.socket.addEventListener(\"close\", this.closed.bind(this));\r\n    this.socket.addEventListener(\"error\", this.errored.bind(this));\r\n    await this.wait();\r\n  }\r\n\r\n  /**\r\n   * Wait for websocket connection to be established\r\n   */\r\n  private wait(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      if (this.socket.readyState === this.socket.OPEN) {\r\n        resolve();\r\n        return;\r\n      }\r\n      this.once(\"open\", () => resolve());\r\n    });\r\n  }\r\n\r\n  private async open() {\r\n    console.info(\"connected to server\");\r\n    // Authenticate if needed\r\n    if (this.options.password) {\r\n      try {\r\n        await this.authWithPassword(this.options.password);\r\n      } catch (e) {\r\n        this.fire(\"error\", e);\r\n        this.close();\r\n      }\r\n    } else if (this.options.interactive) {\r\n      try {\r\n        await this.authInteractive(this.options.interactiveData ?? {});\r\n      } catch (e) {\r\n        this.fire(\"error\", e);\r\n        this.close();\r\n      }\r\n    }\r\n    this.resubscribe();\r\n    this.fire(\"open\");\r\n    this.fire(\"stateChange\", this.socket.readyState);\r\n  }\r\n\r\n  private closed(ev: CloseEvent) {\r\n    console.warn(`lost connection to server: ${ev.reason}`);\r\n    this.fire(\"close\", ev);\r\n    this.fire(\"stateChange\", this.socket.readyState);\r\n    // Try reconnecting after a few seconds\r\n    if (this.options.reconnect) {\r\n      setTimeout(() => this.reconnect(), 5000);\r\n    }\r\n  }\r\n\r\n  private errored(ev: Event) {\r\n    this.fire(\"error\", ev);\r\n  }\r\n\r\n  private received(event: MessageEvent) {\r\n    const events = (event.data as string)\r\n      .split(\"\\n\")\r\n      .map((ev) => ev.trim())\r\n      .filter((ev) => ev.length > 0);\r\n    events.forEach((ev) => {\r\n      const response: KilovoltMessage = JSON.parse(ev ?? '\"\"');\r\n      if (\"error\" in response) {\r\n        this.fire(\"error\", response);\r\n        if (\"request_id\" in response && response.request_id in this.pending) {\r\n          this.pending[response.request_id](response);\r\n          delete this.pending[response.request_id];\r\n        }\r\n        return;\r\n      }\r\n      switch (response.type) {\r\n        case \"response\":\r\n          if (response.request_id in this.pending) {\r\n            this.pending[response.request_id](response);\r\n            delete this.pending[response.request_id];\r\n          } else {\r\n            console.warn(\r\n              \"Received a response for an unregistered request: \",\r\n              response\r\n            );\r\n          }\r\n          break;\r\n        case \"push\": {\r\n          if (response.key in this.keySubscriptions) {\r\n            this.keySubscriptions[response.key].forEach((fn) =>\r\n              fn(response.new_value, response.key)\r\n            );\r\n          }\r\n          Object.entries(this.prefixSubscriptions)\r\n            .filter(([k]) => response.key.startsWith(k))\r\n            .forEach(([_, subscribers]) => {\r\n              subscribers.forEach((fn) => fn(response.new_value, response.key));\r\n            });\r\n          break;\r\n        }\r\n        default:\r\n        // Do nothing\r\n      }\r\n    });\r\n  }\r\n\r\n  private async authWithPassword(password: string) {\r\n    // Ask for challenge\r\n    const request = (await this.send<kvLogin>({\r\n      command: \"klogin\",\r\n      data: { auth: \"challenge\" },\r\n    })) as kvError | kvGenericResponse<{ challenge: string; salt: string }>;\r\n    if (\"error\" in request) {\r\n      console.error(\"kilovolt auth error:\", request.error);\r\n      throw new Error(request.error);\r\n    }\r\n    // Calculate hash and send back\r\n    const hash = await authChallenge(\r\n      password ?? \"\",\r\n      request.data.challenge,\r\n      request.data.salt\r\n    );\r\n    const response = (await this.send<kvAuth>({\r\n      command: \"kauth\",\r\n      data: { hash },\r\n    })) as kvError | kvEmptyResponse;\r\n    if (\"error\" in response) {\r\n      console.error(\"kilovolt auth error:\", response.error);\r\n      throw new Error(response.error);\r\n    }\r\n  }\r\n\r\n  private async authInteractive(data: Record<string, unknown>) {\r\n    // Ask for interactive auth\r\n    const request = (await this.send<kvLogin>({\r\n      command: \"klogin\",\r\n      data: { ...data, auth: \"ask\" },\r\n    })) as kvError | kvGenericResponse<{ challenge: string; salt: string }>;\r\n    if (\"error\" in request) {\r\n      console.error(\"kilovolt auth error:\", request.error);\r\n      throw new Error(request.error);\r\n    }\r\n  }\r\n\r\n  private async resubscribe() {\r\n    for (const key in this.keySubscriptions) {\r\n      await this.send<kvSubscribeKey>({\r\n        command: \"ksub\",\r\n        data: {\r\n          key,\r\n        },\r\n      });\r\n    }\r\n    for (const prefix in this.prefixSubscriptions) {\r\n      this.send<kvSubscribePrefix>({\r\n        command: \"ksub-prefix\",\r\n        data: {\r\n          prefix,\r\n        },\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a request to the server\r\n   * @param msg Request to send\r\n   * @returns Response from server\r\n   */\r\n  send<T extends KilovoltRequest>(\r\n    msg: T | Omit<T, \"request_id\">\r\n  ): Promise<KilovoltMessage> {\r\n    if (this.socket.readyState !== this.socket.OPEN) {\r\n      throw new Error(\"Not connected to server\");\r\n    }\r\n    const message = {\r\n      ...msg,\r\n      request_id: \"request_id\" in msg ? msg.request_id : generateRid(),\r\n    };\r\n    return new Promise((resolve) => {\r\n      const payload = JSON.stringify(message);\r\n      this.socket.send(payload);\r\n      this.pending[message.request_id] = resolve;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set a key to a specified value\r\n   * @param key Key to set\r\n   * @param data Value to set\r\n   * @returns Reply from server\r\n   */\r\n  putKey(key: string, data: string): Promise<KilovoltMessage> {\r\n    return this.send<kvSet>({\r\n      command: \"kset\",\r\n      data: {\r\n        key,\r\n        data,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set multiple keys at once\r\n   * @param data Map of key:value data to set\r\n   * @returns Reply from server\r\n   */\r\n  putKeys(data: Record<string, string>): Promise<KilovoltMessage> {\r\n    return this.send<kvSetBulk>({\r\n      command: \"kset-bulk\",\r\n      data,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set a key to the JSON representation of an object\r\n   * @param key Key to set\r\n   * @param data Object to save\r\n   * @returns Reply from server\r\n   */\r\n  putJSON<T>(key: string, data: T): Promise<KilovoltMessage> {\r\n    return this.send<kvSet>({\r\n      command: \"kset\",\r\n      data: {\r\n        key,\r\n        data: JSON.stringify(data),\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set multiple keys at once\r\n   * @param data Map of key:value data to set\r\n   * @returns Reply from server\r\n   */\r\n  putJSONs(data: Record<string, unknown>): Promise<KilovoltMessage> {\r\n    const jsonData: Record<string, string> = {};\r\n    Object.entries(data).forEach(([k, v]) => {\r\n      jsonData[k] = JSON.stringify(v);\r\n    });\r\n    return this.send<kvSetBulk>({\r\n      command: \"kset-bulk\",\r\n      data: jsonData,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieve value for key\r\n   * @param key Key to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getKey(key: string): Promise<string> {\r\n    const response = (await this.send<kvGet>({\r\n      command: \"kget\",\r\n      data: {\r\n        key,\r\n      },\r\n    })) as kvError | kvGenericResponse<string>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * Retrieve value for key\r\n   * @param keys Keys to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getKeys(keys: string[]): Promise<Record<string, string>> {\r\n    const response = (await this.send<kvGetBulk>({\r\n      command: \"kget-bulk\",\r\n      data: {\r\n        keys,\r\n      },\r\n    })) as kvError | kvGenericResponse<Record<string, string>>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * Retrieve all keys with given prefix\r\n   * @param prefix Prefix for keys to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getKeysByPrefix(prefix: string): Promise<Record<string, string>> {\r\n    const response = (await this.send<kvGetAll>({\r\n      command: \"kget-all\",\r\n      data: {\r\n        prefix,\r\n      },\r\n    })) as kvError | kvGenericResponse<Record<string, string>>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * Retrieve object from key, deserialized from JSON.\r\n   * It's your responsibility to make sure the object is actually what you expect\r\n   * @param key Key to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getJSON<T>(key: string): Promise<T> {\r\n    const response = (await this.send<kvGet>({\r\n      command: \"kget\",\r\n      data: {\r\n        key,\r\n      },\r\n    })) as kvError | kvGenericResponse<string>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return JSON.parse(response.data);\r\n  }\r\n\r\n  /**\r\n   * Retrieve objects from keys, deserialized from JSON.\r\n   * It's your responsibility to make sure the object is actually what you expect\r\n   * @param key Key to retrieve\r\n   * @returns Reply from server\r\n   */\r\n  async getJSONs<T>(keys: string[]): Promise<T> {\r\n    const response = (await this.send<kvGetBulk>({\r\n      command: \"kget-bulk\",\r\n      data: {\r\n        keys,\r\n      },\r\n    })) as kvError | kvGenericResponse<Record<string, string>>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    const returnData: Record<string, unknown> = {};\r\n    Object.entries(response.data).forEach(([k, v]) => {\r\n      returnData[k] = JSON.parse(v);\r\n    });\r\n    return returnData as T;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to key changes\r\n   * @param key Key to subscribe to\r\n   * @param fn Callback to call when key changes\r\n   * @returns Reply from server\r\n   */\r\n  subscribeKey(key: string, fn: SubscriptionHandler): Promise<KilovoltMessage> {\r\n    if (key in this.keySubscriptions) {\r\n      this.keySubscriptions[key].push(fn);\r\n    } else {\r\n      this.keySubscriptions[key] = [fn];\r\n    }\r\n\r\n    return this.send<kvSubscribeKey>({\r\n      command: \"ksub\",\r\n      data: {\r\n        key,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop calling a callback when its related key changes\r\n   * This only\r\n   * @param key Key to unsubscribe from\r\n   * @param fn Callback to stop calling\r\n   * @returns true if a subscription was removed, false otherwise\r\n   */\r\n  async unsubscribeKey(key: string, fn: SubscriptionHandler): Promise<boolean> {\r\n    if (!(key in this.keySubscriptions)) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from key \"${key}\" but no subscriptions could be found!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Get subscriber in list\r\n    const index = this.keySubscriptions[key].findIndex((subfn) => subfn === fn);\r\n    if (index < 0) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from key \"${key}\" but specified function is not in the subscribers!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Remove subscriber from list\r\n    this.keySubscriptions[key].splice(index, 1);\r\n\r\n    // Check if array is empty\r\n    if (this.keySubscriptions[key].length < 1) {\r\n      // Send unsubscribe\r\n      const res = (await this.send<kvUnsubscribeKey>({\r\n        command: \"kunsub\",\r\n        data: {\r\n          key,\r\n        },\r\n      })) as kvError | kvGenericResponse<void>;\r\n      if (\"error\" in res) {\r\n        console.warn(`unsubscribe failed: ${res.error}`);\r\n      }\r\n      return res.ok;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to key changes on a prefix\r\n   * @param prefix Prefix of keys to subscribe to\r\n   * @param fn Callback to call when key changes\r\n   * @returns Reply from server\r\n   */\r\n  subscribePrefix(\r\n    prefix: string,\r\n    fn: SubscriptionHandler\r\n  ): Promise<KilovoltMessage> {\r\n    if (prefix in this.keySubscriptions) {\r\n      this.prefixSubscriptions[prefix].push(fn);\r\n    } else {\r\n      this.prefixSubscriptions[prefix] = [fn];\r\n    }\r\n\r\n    return this.send<kvSubscribePrefix>({\r\n      command: \"ksub-prefix\",\r\n      data: {\r\n        prefix,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop calling a callback when their prefix's related key changes\r\n   * This only\r\n   * @param prefix Prefix to unsubscribe from\r\n   * @param fn Callback to stop calling\r\n   * @returns true if a subscription was removed, false otherwise\r\n   */\r\n  async unsubscribePrefix(\r\n    prefix: string,\r\n    fn: SubscriptionHandler\r\n  ): Promise<boolean> {\r\n    if (!(prefix in this.prefixSubscriptions)) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from prefix \"${prefix}\" but no subscriptions could be found!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Get subscriber in list\r\n    const index = this.prefixSubscriptions[prefix].findIndex(\r\n      (subfn) => subfn === fn\r\n    );\r\n    if (index < 0) {\r\n      // No subscriptions, just warn and return\r\n      console.warn(\r\n        `Trying to unsubscribe from key \"${prefix}\" but specified function is not in the subscribers!`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // Remove subscriber from list\r\n    this.prefixSubscriptions[prefix].splice(index, 1);\r\n\r\n    // Check if array is empty\r\n    if (this.prefixSubscriptions[prefix].length < 1) {\r\n      // Send unsubscribe\r\n      const res = (await this.send<kvUnsubscribePrefix>({\r\n        command: \"kunsub-prefix\",\r\n        data: {\r\n          prefix,\r\n        },\r\n      })) as kvError | kvGenericResponse<void>;\r\n      if (\"error\" in res) {\r\n        console.warn(`unsubscribe failed: ${res.error}`);\r\n      }\r\n      return res.ok;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of saved keys with the given prefix.\r\n   * If no prefix is given then returns all the keys.\r\n   * @param prefix Optional prefix\r\n   * @returns List of keys\r\n   */\r\n  async keyList(prefix?: string): Promise<string[]> {\r\n    const response = (await this.send<kvKeyList>({\r\n      command: \"klist\",\r\n      data: {\r\n        prefix: prefix ?? \"\",\r\n      },\r\n    })) as kvError | kvGenericResponse<string[]>;\r\n\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * Delete key from store\r\n   * @param key Key to delete\r\n   * @returns Reply from server\r\n   */\r\n  async deleteKey(key: string): Promise<string> {\r\n    const response = (await this.send<kvDelete>({\r\n      command: \"kdel\",\r\n      data: {\r\n        key,\r\n      },\r\n    })) as kvError | kvGenericResponse<string>;\r\n    if (\"error\" in response) {\r\n      throw new Error(response.error);\r\n    }\r\n    return response.data;\r\n  }\r\n}\r\n\r\nexport default Kilovolt;\r\n"],
  "mappings": "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",
  "names": ["b64alphabet", "b64array", "base64ToBytesArr", "str", "result", "i", "bytes", "x", "__name", "bytesArrToBase64", "arr", "bin", "n", "l", "c1", "c2", "r", "j", "EventEmitter", "eventName", "listener", "detail", "generateRid", "__name", "authChallenge", "password", "challenge", "salt", "keyBytes", "saltBytes", "base64ToBytesArr", "challengeKey", "challengeBytes", "key", "signature", "bytesArrToBase64", "Kilovolt", "EventEmitter", "address", "options", "resolve", "_a", "e", "ev", "event", "response", "fn", "k", "_", "subscribers", "request", "hash", "data", "__spreadProps", "__spreadValues", "prefix", "msg", "message", "payload", "jsonData", "v", "keys", "returnData", "index", "subfn", "res", "ts_default"]
}
