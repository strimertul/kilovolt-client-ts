var g=Object.defineProperty,w=Object.defineProperties;var E=Object.getOwnPropertyDescriptors;var b=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable;var v=(i,n,e)=>n in i?g(i,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[n]=e,f=(i,n)=>{for(var e in n||(n={}))P.call(n,e)&&v(i,e,n[e]);if(b)for(var e of b(n))K.call(n,e)&&v(i,e,n[e]);return i},y=(i,n)=>w(i,E(n)),a=(i,n)=>g(i,"name",{value:n,configurable:!0});var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",x=[...m];function l(i){let n=[];for(let e=0;e<i.length/4;e++){let t=[...i.slice(4*e,4*e+4)].map(o=>x.indexOf(o).toString(2).padStart(6,"0")).join("").match(/.{1,8}/g).map(o=>+("0b"+o));n.push(...t.slice(0,3-(i[4*e+2]=="="?1:0)-(i[4*e+3]=="="?1:0)))}return n}a(l,"base64ToBytesArr");function S(i){let n=a(r=>r.toString(2).padStart(8,"0"),"bin"),e=i.length,s="";for(let r=0;r<=(e-1)/3;r++){let t=r*3+1>=e,o=r*3+2>=e,c=(n(i[3*r])+n(t?0:i[3*r+1])+n(o?0:i[3*r+2])).match(/.{1,6}/g).map((k,p)=>p==3&&o||p==2&&t?"=":m[+("0b"+k)]);s+=c.join("")}return s}a(S,"bytesArrToBase64");var u=class extends EventTarget{on(n,e){return this.addEventListener(n,e)}once(n,e){return this.addEventListener(n,e,{once:!0})}off(n,e){return this.removeEventListener(n,e)}fire(n,e){return this.dispatchEvent(new CustomEvent(n,{detail:e,cancelable:!0}))}};a(u,"EventEmitter");function R(){return Math.random().toString(32)}a(R,"generateRid");async function O(i,n,e){let r=new TextEncoder().encode(i),t=l(e),o=Uint8Array.from([...r,...t]),d=l(n),c=await crypto.subtle.importKey("raw",o,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"]),k=await crypto.subtle.sign("HMAC",c,Uint8Array.from(d));return S(Array.from(new Uint8Array(k)))}a(O,"authChallenge");var h=class extends u{constructor(e="ws://localhost:4337/ws",s,r){super();this.address=e,this.password=s,this.pending={},this.keySubscriptions={},this.prefixSubscriptions={},this.options=r||{},this.connect(e)}reconnect(){this.connect(this.address)}close(){this.options.reconnect=!1,this.socket.close()}connect(e){this.socket=new WebSocket(e),this.socket.addEventListener("open",this.open.bind(this)),this.socket.addEventListener("message",this.received.bind(this)),this.socket.addEventListener("close",this.closed.bind(this)),this.socket.addEventListener("error",this.errored.bind(this))}wait(){return new Promise(e=>{if(this.socket.readyState===this.socket.OPEN){e();return}this.once("open",()=>e())})}async open(){if(console.info("connected to server"),this.password)try{await this.auth()}catch(e){this.fire("error",e),this.close()}this.resubscribe(),this.fire("open"),this.fire("stateChange",this.socket.readyState)}closed(e){console.warn(`lost connection to server: ${e.reason}`),this.fire("close",e),this.fire("stateChange",this.socket.readyState),this.options.reconnect&&setTimeout(()=>this.reconnect(),5e3)}errored(e){this.fire("error",e)}received(e){e.data.split(`
`).map(r=>r.trim()).filter(r=>r.length>0).forEach(r=>{let t=JSON.parse(r!=null?r:'""');if("error"in t){this.fire("error",t),"request_id"in t&&t.request_id in this.pending&&(this.pending[t.request_id](t),delete this.pending[t.request_id]);return}switch(t.type){case"response":t.request_id in this.pending?(this.pending[t.request_id](t),delete this.pending[t.request_id]):console.warn("Received a response for an unregistered request: ",t);break;case"push":{t.key in this.keySubscriptions&&this.keySubscriptions[t.key].forEach(o=>o(t.new_value,t.key)),Object.entries(this.prefixSubscriptions).filter(([o])=>t.key.startsWith(o)).forEach(([o,d])=>{d.forEach(c=>c(t.new_value,t.key))});break}default:}})}async auth(){var t;let e=await this.send({command:"klogin"});if("error"in e)throw console.error("kilovolt auth error:",e.error),new Error(e.error);let s=await O((t=this.password)!=null?t:"",e.data.challenge,e.data.salt),r=await this.send({command:"kauth",data:{hash:s}});if("error"in r)throw console.error("kilovolt auth error:",r.error),new Error(r.error)}async resubscribe(){for(let e in this.keySubscriptions)await this.send({command:"ksub",data:{key:e}});for(let e in this.prefixSubscriptions)this.send({command:"ksub-prefix",data:{prefix:e}})}send(e){if(this.socket.readyState!==this.socket.OPEN)throw new Error("Not connected to server");let s=y(f({},e),{request_id:"request_id"in e?e.request_id:R()});return new Promise(r=>{let t=JSON.stringify(s);this.socket.send(t),this.pending[s.request_id]=r})}putKey(e,s){return this.send({command:"kset",data:{key:e,data:s}})}putKeys(e){return this.send({command:"kset-bulk",data:e})}putJSON(e,s){return this.send({command:"kset",data:{key:e,data:JSON.stringify(s)}})}putJSONs(e){let s={};return Object.entries(e).forEach(([r,t])=>{s[r]=JSON.stringify(t)}),this.send({command:"kset-bulk",data:s})}async getKey(e){let s=await this.send({command:"kget",data:{key:e}});if("error"in s)throw new Error(s.error);return s.data}async getKeys(e){let s=await this.send({command:"kget-bulk",data:{keys:e}});if("error"in s)throw new Error(s.error);return s.data}async getKeysByPrefix(e){let s=await this.send({command:"kget-all",data:{prefix:e}});if("error"in s)throw new Error(s.error);return s.data}async getJSON(e){let s=await this.send({command:"kget",data:{key:e}});if("error"in s)throw new Error(s.error);return JSON.parse(s.data)}async getJSONs(e){let s=await this.send({command:"kget-bulk",data:{keys:e}});if("error"in s)throw new Error(s.error);let r={};return Object.entries(s.data).forEach(([t,o])=>{r[t]=JSON.parse(o)}),r}subscribeKey(e,s){return e in this.keySubscriptions?this.keySubscriptions[e].push(s):this.keySubscriptions[e]=[s],this.send({command:"ksub",data:{key:e}})}async unsubscribeKey(e,s){if(!(e in this.keySubscriptions))return console.warn(`Trying to unsubscribe from key "${e}" but no subscriptions could be found!`),!1;let r=this.keySubscriptions[e].findIndex(t=>t===s);if(r<0)return console.warn(`Trying to unsubscribe from key "${e}" but specified function is not in the subscribers!`),!1;if(this.keySubscriptions[e].splice(r,1),this.keySubscriptions[e].length<1){let t=await this.send({command:"kunsub",data:{key:e}});return"error"in t&&console.warn(`unsubscribe failed: ${t.error}`),t.ok}return!0}subscribePrefix(e,s){return e in this.keySubscriptions?this.prefixSubscriptions[e].push(s):this.prefixSubscriptions[e]=[s],this.send({command:"ksub-prefix",data:{prefix:e}})}async unsubscribePrefix(e,s){if(!(e in this.prefixSubscriptions))return console.warn(`Trying to unsubscribe from prefix "${e}" but no subscriptions could be found!`),!1;let r=this.prefixSubscriptions[e].findIndex(t=>t===s);if(r<0)return console.warn(`Trying to unsubscribe from key "${e}" but specified function is not in the subscribers!`),!1;if(this.prefixSubscriptions[e].splice(r,1),this.prefixSubscriptions[e].length<1){let t=await this.send({command:"kunsub-prefix",data:{prefix:e}});return"error"in t&&console.warn(`unsubscribe failed: ${t.error}`),t.ok}return!0}async keyList(e){let s=await this.send({command:"klist",data:{prefix:e!=null?e:""}});if("error"in s)throw new Error(s.error);return s.data}};a(h,"Kilovolt");var q=h;export{h as Kilovolt,q as default};
//# sourceMappingURL=kilovolt.js.map
